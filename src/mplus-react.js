import React from "react";
import flyd from "flyd";

let kont = {};

const resolveContainer = (contid, container) => {
  if (kont[contid]) {
    kont[contid].resolve(container);
  } else {
    kont[contid] = Promise.resolve(container);
  }
};

const getDeferredContainer = contId => {
  if (kont[contId]) {
    return kont[contId];
  }
  let _resolve, _reject;
  let prom = new Promise(function(resolve, reject) {
    _resolve = resolve;
    _reject = reject;
  });
  prom.resolve = _resolve;
  prom.reject = _reject;
  kont[contId] = prom;
  return prom;
};

export const animating = flyd.stream(false);

export let rootComponent = null;

//this is going to be set from ref in the main component

export const openDialog = dialog => {
  if (!rootComponent) {
    return;
  }
  let newDialogs = rootComponent.state.dialogs.slice();
  newDialogs.push(dialog);
  rootComponent.setState({ dialogs: newDialogs });
};

export const closeDialog = () => {
  if (!rootComponent) {
    return;
  }
  let newDialogs = rootComponent.state.dialogs.slice();
  newDialogs.pop();
  rootComponent.setState({ dialogs: newDialogs });
};

class AppContainer extends React.Component {
  constructor(props) {
    super(props);
    let mp = new maximoplus.basecontrols.AppContainer(
      this.props.mboname,
      this.props.appname
    );
    if (this.props.offlineenabled) {
      mp.setOfflineEnabled(true);
    }
    resolveContainer(this.props.id, mp);
    this.state = { mp: mp };
  }

  render() {
    return <div mboname={this.props.mboname} appname={this.props.appname} />;
  }

  componentWillUnmount() {
    this.state.mp.dispose();
    delete kont[this.props.id];
  }
}

class RelContainer extends React.Component {
  construnctor(props) {
    getDeferredContainer(this.props.container).then(mboCont => {
      let mp = new maximoplus.basecontrols.RelContainer(
        mboCont,
        this.props.relationship
      );
      this.state = { mp: mp };
      resolveContainer(this.props.id, mp);
    });
  }

  render() {
    return (
      <div
        container={this.props.container}
        relationship={this.props.relationship}
      />
    );
  }

  compnentWillUnmount() {
    this.state.mp.dispose();
    delete kont[this.props.id];
  }
}

const tickData = data =>
  data == "Y" ? <div style="flex:1">&#x2713;</div> : <div />;

const listTemplates = {
  porow: o => (
    <div
      style="
    /* border-bottom: blue; */
    border-bottom-width: 1px;
    border-bottom-style: solid;
    border-bottom-color: grey;
    padding-bottom: 3px;
"
      onClick={o.rowSelectedAction}
    >
      <div>
        {o.data.PONUM} {o.data.STATUS}
      </div>
      <div>Order Date: {o.data.ORDERDATE}</div>
      <div>{o.data.DESCRIPTION}</div>
    </div>
  ),
  valuelist: o => (
    <div onClick={o.rowSelectedAction}>
      <div>{o.data.VALUE}</div>
      <div>{o.data.DESCRIPTION}</div>
    </div>
  ),
  qbevaluelist: o => (
    <div style="display:flex;flex-direction:row; align-items: center; justify-content: center;">
      {tickData(o.data._SELECTED)}
      <div style="flex:5" onClick={o.rowSelectedAction}>
        <div>{o.data.VALUE}</div>
        <div>{o.data.DESCRIPTION}</div>
      </div>
    </div>
  ),
  gllist: o => (
    <div onClick={o.rowSelectedAction}>
      <div>{o.data.COMPVALUE}</div>
      <div>{o.data.COMPTEXT}</div>
    </div>
  ),
  personlist: o => (
    <div onClick={o.rowSelectedAction}>
      <div>{o.data.PERSONID}</div>
      <div>{o.data.DISPLAYNAME}</div>
    </div>
  ),
  doclinks: o => (
    <div onClick={o.rowSelectedAction}>
      <div>
        {o.data.DOCTYPE} {o.data.DOCUMENT} {o.data.DESCRIPTION}
      </div>
      <div>
        {o.data.CHANGEDATE} {o.data.CHANGEBY}
      </div>
    </div>
  )
}; //this should be in separate file and autogenerated from the visual tool

const filterTemplates = {
  valuelist: (cont, dialog) => (
    <qbe-section
      maxcontainer={cont}
      filterDialog={dialog}
      columns={["value", "description"]}
    />
  )
}; //also in separated file and generated from the tool
